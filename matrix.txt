#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <dingyi.h>
float**mal(int a,int b);
float evaluation(float**a,int x);
float**companion(float**a,int x) ;
float**inverse(float**a,int x);
float**division(float**a,float**b,int x,int y);
float **multiplication1(float**a,float**b,int x,int y,int z);
float** transport(float**a,int x,int y);
int main()
{
    float**a,**b,**div,**mul,**inv,**tra;//建立输入与结果双重指针
    int i,j;
    char ad[100],bd[100],jgd[100];
    float x[2],y[2];//维数数组
    FILE*pt1;//文件指针
    FILE*pt2;
    FILE*pt3;

    printf("choose your first document:");//文件地址
    scanf("%s",ad);
    printf("choose your sceond document:");
    scanf("%s",bd);
    printf("choose your third document:");
    scanf("%s",jgd);

    pt1=fopen(ad,"r");//指向文件
    pt2=fopen(bd,"r");
    pt3=fopen(jgd,"w");

    for(i=0;i<2;i++)//读取维数
    {
        fscanf(pt1,"%f",&x[i]);
    }
    for(i=0;i<2;i++)
    {
        fscanf(pt2,"%f",&y[i]);
    }

    a=mal(x[0],x[1]);//建立动态二维数组
    b=mal(y[0],y[1]);
    div=mal(x[0],x[1]);
    mul=mal(x[0],y[1]);
    inv=mal(x[0],x[0]);
    tra=mal(x[1],x[0]);
//----------------------------------------------
    for(i=0;i<x[0];i++)//读取矩阵
    {
        for(j=0;j<x[1];j++)
        {
            fscanf(pt1,"%f",&a[i][j]);
        }
    }
    for(i=0;i<y[0];i++)
    {
        for(j=0;j<y[1];j++)
        {
            fscanf(pt2,"%f",&b[i][j]);
        }
    }
//****************************************************************************************************************************
//****************************************************************************************************************************
//--------------------------------------------------------------------
    tra=transport(a,x[0],x[1]);//矩阵转置
    fprintf(pt3,"transport matrix:\n");
    printf("transport finished!\n");
    for(i=0;i<x[1];i++)
    {
        for(j=0;j<x[0];j++)
        {
            fprintf(pt3,"%f\t",tra[i][j]);
        }
        fprintf(pt3,"\n");
     }
//------------------------------------------------------------------
    if(x[1]==y[0])//矩阵乘法
    {
        mul=multiplication1(a,b,x[0],x[1],y[1]);
        fprintf(pt3,"multiplication matrix:\n");
        printf("multiplication finished!\n");
        for(i=0;i<x[0];i++)
        {
            for(j=0;j<y[1];j++)
            {
                fprintf(pt3,"%f\t",mul[i][j]);
            }
                fprintf(pt3,"\n");
        }
            fprintf(pt3,"\n");
    }
    else
    {
        printf("can't multiplication1\n");
    }
//--------------------------------------------------------------------
    if((x[0]==x[1])&&evaluation(a,x[0])!=0)//逆矩阵
    {
        inv=inverse(a,x[0]);
        fprintf(pt3,"inverse matrix:\n");
        printf("inverse finished!\n");
        for(i=0;i<x[0];i++)
        {
            for(j=0;j<x[0];j++)
            {
                fprintf(pt3,"%f\t",inv[i][j]);
            }
            fprintf(pt3,"\n");
        }
        fprintf(pt3,"\n");
    }
    else
    {
        printf("can't inverse\n");
    }
//---------------------------------------------------------------
    if((x[1]==y[0])&&y[0]==y[1]&&evaluation(b,y[0])!=0)//矩阵除法
    {
    div=division(a,b,x[0],x[1]);
    fprintf(pt3,"division matrix:\n");
    printf("division finished!\n");
    for(i=0;i<x[0];i++)
    {
        for(j=0;j<x[1];j++)
        {
            fprintf(pt3,"%f\t",div[i][j]);
        }
        fprintf(pt3,"\n");
    }
    fprintf(pt3,"\n");
    }
    else
    {
        printf("can't division\n");
    }


//------------------------------------------------------------------
    for(i=0;i<x[0];i++)//动态数组释放
    {
        free(inv[i]);
        free(tra[i]);
    }
    for(i=0;i<y[1];i++)
    {
        free(b[i]);
        free(mul[i]);
    }
    for(i=0;i<x[1];i++)
    {
        free(a[i]);
        free(div[i]);
    }

    fclose(pt1);//文件关闭
    fclose(pt2);
    fclose(pt1);
    return 0;
}
float**mal(int a,int b)
{
    float**a1;
    int i;
    a1=(float**)malloc(a*sizeof(float*));
    for(i=0;i<a;i++)
    {
        a1[i]=(float*)malloc(b*sizeof(float));
    }
    return a1;
}
//---------------------------------------------------------------------------
float evaluation(float**a,int x)                           //高斯求行列式
{
    int i,j,k,mm,index,m=0,max;
    float gaosi[x][x],flag,other=1,place;
    for(i=0;i<x;i++)
    {
        for(j=0;j<x;j++)
        {
            gaosi[i][j]=a[i][j];
        }
    }
    float det;
    float ss=1;
    for(i=0;i<x-1;i++)                                  //减行
    {
        index=i;
        place=gaosi[i][i];
        for(max=i+1;max<x;max++)
        {
            if(fabs(place)<fabs(gaosi[max][i]))
            {
                place=gaosi[max][i];
                index=max;
            }
        }
        if(index!=i)
        {
            for(mm=0;mm<x;mm++)
            {
                flag=gaosi[i][mm];
                gaosi[i][mm]=gaosi[index][mm];
                gaosi[index][mm]=flag;
            }
            m++;
        }
        if(gaosi[i][i]==0)
        {
            other=0;
        }
        else
        {
            for(j=i+1;j<x;j++)                              //被减行
            {
                det=gaosi[j][i]/gaosi[i][i];
                for(k=i;k<x;k++)                          //运算的列项
                {
                    gaosi[j][k]=gaosi[j][k]-det*gaosi[i][k];
                }

            }
        }
    }
    if(other==1)
    {
        for(i=0;i<x;i++)
        {
            ss=ss*gaosi[i][i];
        }
        return pow(-1,m)*ss;
    }
    else
    {
        return 0;
    }
}
//--------------------------------------------------------------
float**companion(float**a,int x)  //伴随矩阵
{
    float**bansui2;
    float**bansui1;
    bansui1=mal(x-1,x-1);
    int k,z,m=0,n=0;
    int i,j;
    bansui2=mal(x,x);
    for(i=0;i<x;i++)
    {
        for(j=0;j<x;j++)
        {
            m=0;
            for(k=0;k<x;k++)
            {
                n=0;
                if(k==i)continue;
                for(z=0;z<x;z++)
                {
                    if(z==j)continue;
                    bansui1[m][n]=a[k][z];
                   // printf("\n%d %d",m,n);
                    n=n+1;
                }
                m=m+1;
            }
            bansui2[j][i]=pow(-1,i+j)*evaluation(bansui1,x-1);
        }
    }
    return bansui2;
}
//-----------------------------------------------------------------------------
float**inverse(float**a,int x)                                                    //逆矩阵
{
    float**nijuzhen1;
    nijuzhen1=mal(x,x);
    int i,j;
    float**nijuzhen2;
    nijuzhen2=mal(x,x);
    nijuzhen2=companion(a,x);
    for(i=0;i<x;i++)
    {
        for(j=0;j<x;j++)
        {
            nijuzhen1[i][j]=nijuzhen2[i][j]/evaluation(a,x);
        }
    }
    return nijuzhen1;
}
//----------------------------------------------------------------------------
float**division(float**a,float**b,int x,int y)                                      //矩阵除法
{
    float**c,**d;
    c=mal(y,y);
    d=mal(x,y);
    c=inverse(b,y);
    d=multiplication1(a,c,x,y,y);
    return d;
}
//---------------------------------------------------------------
float **multiplication1(float **a,float **b,int x,int y,int z)//矩阵乘法
{
    float**c,tem=0;
    int i,j,k;
    c=(float**)malloc(x*sizeof(float*));
    for(i=0;i<x;i++)
    {
        c[i]=malloc(z*sizeof(float));
    }
    for(i=0;i<x;i++)
    {
        for(j=0;j<z;j++)
        {
            tem=0;
            for(k=0;k<y;k++)
            {
                tem=tem+a[i][k]*b[k][j];
            }
            c[i][j]=tem;
        }
    }
    return c;
}
//------------------------------------------
float** transport(float**a,int x,int y)                         //矩阵转置
{
    float**zhuanzhi;
    int i,j;
    zhuanzhi=mal(y,x);
    for(i=0;i<y;i++)
    {
        for(j=0;j<x;j++)
        {
            zhuanzhi[i][j]=a[j][i];
        }
    }
    return zhuanzhi;
}



